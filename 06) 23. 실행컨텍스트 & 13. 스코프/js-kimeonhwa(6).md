23장 실행 컨텍스트 &  13장 스코프



23장 실행 컨텍스트

> 실행 컨텍스트(`execution context`) 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다.
> 스코프를 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식과 호이스팅이 발생하는 이유, 클로저의 동작 방식, 그리고 태스트 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리의 동작 방식을 이해할 수 있다.



## 1. 소스코드의 타입

> ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다. 4가지 타입의 소스코드는 실행 컨텍스트를 생성한다.

**1.전역 코드 global code**

> 전역에 존재하는 소스코드를 말한다.
> 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.

전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 그리고 `var`키워드로 선언된 **전역 변수**와 함수 선언문으로 정의된 **전역 함수**를 **전역 객체**의 **프로퍼티**와 **메서드**로 바인딩하여 연결 한다. 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.

**2.함수 코드 function code**

> 함수 내부에 존재하는 소스코드를 말한다.
> 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.

함수코드는 지역 스코프를 생성하고 지역 변수, 매개변수, `arguments`객체를 관리해야 한다. 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다. 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.

**3.eval 코드 eval code**

> 빌트인 전역함수인 eval함수에 인수로 전달되어 실행되는 소스코드를 말한다

`eval`코드는 `strict mode`에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 `eval`코드가 평가되면 `eval`실행 컨텍스트가 생성된다.

**4.모듈 코드 module code**

> 모듈 내부에 존재하는 소스코드를 말한다.
> 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.

모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다. 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.



## 2. 소스코드의 평가와 실행

> 자바스크립트 엔진은 소스코드를 2개의 과정으로 나누어 처리한다. (“소스코드의 평가”, “소스코드의 실행”)

|     구분      | 내용                                                         |
| :-----------: | :----------------------------------------------------------- |
| 소스코드 평가 | - 실행 컨텍스트를 생성. - 변수, 함수등의 선언문 실행 - 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록 |
| 소스코드 실행 | - 선언문을 제외한 소스코드가 순차적으로 실행(런타임) - 실행에 필요한 정보(변수나 함수의 참조)를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득 - 변수 값의 변경등 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록 |

```js
var x;
x = 1;
```

위 예제 같은 경우,
소스코드 평가: 변수 선언문 `var x`를 먼저 실행해 식별자 `x`를 실행 컨텍스트가 관리하는 스코프에 등록하고 `undefined`로 초기화 한다.
소스코드 실행: `var x`는 이미 코드 평가 과정에서 실행 완료 하였으니, 변수 할당문 `x = 1`만 실행된다. 이때 `x`의 변수에 값을 할당 하기 위해 먼저 `x`변수가 선언되었는지 확인한다. 등록 되어 있으니 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리한다.



## 3. 실행컨텍스트의 역할

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

1.전역 코드 평가

- 전역 코드를 실행하기 전에 **전역 코드 평가 과정**을 거쳐 준비를 한다.
- 선언문만 먼저 실행한다.`const x; const y;`
- 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다.
- 이때 `var`키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.(브라우저는 window객체의 프로퍼티와 메서드가 된다.)

2.전역 코드 실행

- 평가 과정이 끝나면 런타임이 시작되어 코드가 순차적으로 실행된다.
- 전역 변수에 값이 할당되고 함수가 호출된다.`x = 1; y = 1;`
- 함수가 호출되면 전역코드의 실행을 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.`foo(100);`

3.함수 코드 평가

- 함수 내부로 진입하면 내부의 문들을 실행하기 전에 **함수 코드 평가 과정**을 거치며 준비한다.
- 매개변수(`a`)와 지역 변수 선언문이`const x; const y;` 먼저 실행되고 실행 컨텍스트가 관리하는 지역 스코프에 등록된다.
- `arguments`객체가 생성되어 지역 스코프에 등록되고, `this`바인딩도 결정된다.

4.함수 코드 실행

- 평가 과정이 끝나면 런타임이 시작되어 코드가 순차적으로 실행된다.
- 매개변수와 지역 변수에 값이 할당`x = 10; y = 10;`되고 `console.log(a + x + y);`메서드가 호출된다. -`console`식별자는 스코프 체인을 통해 검색한다.(현재 스코프에 없으면 상위 스코프로 올라가서 검색)

위와 같이 동작을 관리하기 위해 실행 컨텍스트가 필요하다.

> *※실행 컨텍스트의 필요성*
> -선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.
> -스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 스코프 체인을 통해 상위 스코프로 이동해 검색할 수 있어야 한다.
> -현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 한다. 다시 되돌아 가는것도 가능해야 한다.



**※자바스크립트의 핵심 동작 원리의 구성**

| 실행 컨텍스트 스택  | 실행 컨텍스트의 렉시컬 환경 |
| :-----------------: | :-------------------------: |
| 코드 실행 순서 관리 |    식별자와 스코프 관리     |



**※실행 컨텍스트의 구성**

- 전역 실행 컨텍스트
  - 전역 렉시컬 환경
    - 전역 환경 레코드
      - 객체 환경 레코드
      - 선언적 환경 레코드
    - this 바인딩
    - 외부 렉시컬 환경 참조
- 함수 실행 컨텍스트
  - 함수 렉시컬 환경
    - 함수 환경 레코드
    - this 바인딩
    - 외부 렉시컬 환경 참조





## 4. 실행 컨텍스트 스택

> 소스코드의 타입별로(전역 코드나 함수 코드) 자바스크립트 엔진은 코드를 평가하여 실행 컨텍스트를 생성하는데, 실행 컨텍스트를 스택 자료구조로 관리한다. 이를 **실행 컨텍스트 스택**이라고 한다.
> **실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.**

```js
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```



1.전역 코드의 평가와 실행
-전역 코드를 평가하여 **전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시**
-이때 전역 변수 `x`와 전역 함수 `foo`는 전역 실행 컨텍스트에 등록
-이후 전역 코드가 실행되어 전역 변수 `x`에 값이 할당되고 전역 함수 `foo`가 호출

2.`foo`함수 코드의 평가와 실행
-`foo`함수가 호출되면 전역 코드의 실행은 중단되고 제어권이 `foo`함수 내부로 이동
-`foo`함수 내부의 함수 코드를 평가하여 `foo`함수 **실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시**
-이때 지역변수 `y`와 중첩함수 `bar`가 `foo`함수 실행 컨텍스트에 등록
-이후 `foo`함수 코드가 실행되어 지역변수`y`에 값이 할당되고 중첩함수 `bar`가 호출

3.`bar`함수 코드의 평가와 실행
-`foo`함수 코드의 실행은 일시 중단되고 제어권이 `bar`함수 내부로 이동
-`bar`함수 코드를 평가하여 `bar`함수 시행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시
-이때 `bar`함수의 지역변수`z`가 `bar`함수 실행 컨텍스트에 등록
-이후 `bar`함수가 실행되어 `z`에 값이 할당되고 `console.log`메서드를 호출 한 이후 `bar`함수는 종료

4.`foo`함수코드로 복귀
-`bar`함수가 종료되면 제어권은 다시 `foo`함수로 이동
-`bar`함수 실행 컨텍스트를 스택에서 팝하여 제거
-`foo`함수 종료

5.전역 코드로 복귀
-`foo`함수가 종료되면 제어권은 다시 전역 코드로 이동
-더이상 실행할 전역코드가 없어 전역 실행 컨텍스트도 스택에서 팝하여 제거

> ※실행 중인 실행 컨텍스트(running execution context)
> -실행 컨텍스트의 최상위에 존재하는 실행 컨텍스트, 현재 실행 중인 코드의 실행 컨텍스트



## 5. 렉시컬 환경

> 렉시컬 환경(`Lexical Environment`)은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.
> **렉시컬 환경은 스코프와 식별자를 관리한다.**

> *※환경 레코드(Environment Record)*
> 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소.
> 환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.

> *※외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)*
> 상위 스코프를 가리킨다.
> 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경
> 단방향 링크드 리스트인 스코프체인을 구현한다.



## 6. 실행 컨텍스트의 생성과 식별자 검색 과정

아래 예재를 통해 과정을 살펴 보자

```js
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); // 42
```



### 6-1 전역 객체 생성

> 전역 객체는 전역 코드가 평가되기 이전에 생성된다.
> 빌드인 전역 프로퍼티와 빌트인 전역함수, 표준 빌트인 객체가 구다되며 동작환경에 따라 클라이언트 사이드 Web API(DOM, BOM, Canvas, XMLHttpRequest, Web Stroage, Web Component, Web Worker등)또는 특정 환경을 위한 호스트 객체를 포함한다.
>
> 전역 객체도 `Object.prototype`을 상속 받는다. 즉 전역 객체도 프로토타입 체인의 일원이다.

```js
// Object.prototype.toString
window.toString(); // -> "[object Window]"

window.__proto__.__proto__.__proto__.__proto__ === Object.prototype; // -> true
```



### 6-2 전역 코드 평가

> - 전역 실행 컨텍스트 생성
> - 전역 렉시컬 환경 생성
>   - 전역 환경 레코드 생성
>     - 객체 환경 레코드 생성
>     - 선언적 환경 레코드 생성
>   - this 바인딩
>   - 외부 렉시컬 환경에 대한 참조 결정



#### 1) 전역 실행 컨텍스트 생성

- 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.

#### 2) 전역 렉시컬 환경

- 전역 렉시컬 환경`Global Lexical Environment`을 생성하고 전역 실행 컨텍스트에 바인딩 한다.

**2-1) 전역 환경 레코드 생성**
-전역 환경 레코드`Global Environment Record`는 전역 변수를 관리하는 전역 스코프
-전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역 함수
-표준 빌트인 객체를 제공



*객체 환경 레코드*
-`var`키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수
-빌트인 전역 프로퍼티와 빌트인 전역 함수
-표준빌트인 객체
-`var`로 선언된 변수와 함수는 `BindingObject`를 통해 전역 객체의 프로퍼티와 메서드가 된다.

*선언적 환경 레코드*
-`let`, `const`키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재
-`window.y`와 같이 참조할 수 없다.
-변수는 “선언 단계”와 “초기화 단계”가 분리되어 있다.
-일시적 사각지대`TDZ Temporal Dead Zone`에 빠지게 된다.

> `et`, `const` 키워드로 선언한 변수도 변수 호이스팅이 발생한다.
> 단 런타임에 제어가 변수 선언문에 도달하기 전까지 일시적 사각지대(TDZ)에 빠지기 때문에 참조할 수 없다.

```js
let foo = 1; // 전역 변수

{
  // let, const 키워드로 선언한 변수가 호이스팅되지 않는다면 전역 변수를 참조해야 한다.
  // 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다.
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```



**2-2) this 바인딩**
전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 `this`가 바인딩된다.

참고로 전역 환경 레코드를 구성하는 *객체 환경 레코드*와 *선언적 환경 레코드*에는 `this`바인딩이 없다. `this`바인딩은 *전역 환경 레코드*와 *함수 환경 레코드*에만 존재한다.

**2-3) 외부 렉시컬 환경에 대한 참조 결정**
현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 상위 스코프를 가리킨다.





### 6-3 전역 코드 실행

> 전역 코드가 순차적으로 실행 된다.
> 변수 할당문이 실행되어 전역 변수 `x`, `y`에 값이 할당된다.
>
> 식별자 결정`Idendifier resolurion`을 위해 실행 컨텍스트에 등록된 식별자를 검색한다.
> 가장 먼저 현재 실행 중인 실행 컨텍스트를 검색
> 없으면 상위 스코프로 이동하여 식별자 검색





### 6-4 foo 함수 코드 평가

이제 `foo(20);`함수를 호출하기 직전이다.
`foo`함수가 호출되면 전역 코드의 실행이 중단되고 제어권이 `foo`함수 내부로 이동한다. 그리고 함수 코드를 평가하기 시작한다.

- 함수 실행 컨텍스트 생성 (1)
- 함수 렉시컬 환경 생성 (2)
  - 함수 환경 레코드 생성 (3)
  - `this`바인딩 (4)
  - 외부 렉시컬 환경에 대한 참조 결정 (5)



#### 1) 함수 실행 컨텍스트 생성

- `foo`함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시된다.

#### 2) 함수 렉시컬 환경 생성

- `foo`함수 렉시컬 환경을 생성하고 `foo`함수 실행 컨텍스트에 바인딩(연결)한다.

**2-1) 함수 환경 레코드 생성**
함수 환경 레코드에는 매개변수, `arguments`객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.



**2-2) this 바인딩**
함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 `this`가 바인딩 된다.
`foo`함수는 일반 함수(메서드X)로 호출되었으므로 `this`는 전역 객체를 가리킨다.



**2-3) 외부 렉시컬 환경에 대한 참조 결정**
`foo`함수는 전역 코드에 정의된 함수이기 때문에 외부 렉시컬 환경 참조에는 전역 렉시컬 환경의 참조가 할당된다.

> ※상위 스코프
> 함수를 어디서 호출했는지가 아니라 어디에 정의 했는지에 따라 상위 스코프를 결정한다.

> ※this 바인딩
> 함수가 어떻게 호출되는지에 따라 this에 바인딩 될 값이 동적으로 결정된다.



### 6-5 foo 함수 코드 실행

이제 런타임이 시작되어 `foo`함수의 코드가 순차적으로 실행된다.
매개변수에 인수가 할당되고(`a`에 `10`할당) 변수 할당문이 실행되어 지역변수 `x`,`y`에 각 `3`,`4`가 할당된다.
그리고 `bar`함수가 호출된다.



### 6-6 bar 함수 코드 평가

이제 `bar`함수로 제어권이 이동하고 `bar`함수 코드를 평가하기 시작하여 실행 컨텍스트가 생성되고 스택에 추가된다. `foo`함수 와 동일하게 `bar`렉시컬 환경을 만들고, 환경 레코드를 생성하고, this바인딩을 하고, 외부 렉시컬 환경 참조를 할당한다.



### 6-7 bar 함수 코드 실행

런타임이 시작되어 `bar`함수의 코드가 실행된다. 매개변수에 인수가 할당(`b`에 `10`할당)되고 `z`에 `5`를 할당한다.
그리고 `console.log(a + b + x + y + z);`가 실행된다.

**1) console 식별자 검색**
`console`식별자를 현재 실행중인 실행 컨텍스트의 렉시컬 환경에서부터 시작해 외부 렉시컬 환경에 대한 참조로 이어서 검색하기 시작한다.
`console`식별자는 `bar` 실행컨텍스트에는 없으니 외부 렉시컬 환경을 따라가 `foo`함수의 렉시컬 환경을 확인하고 거기에도 없으니 전역 실행 렉시컬 환경으로 이동하여 검색한다.
전역 렉시컬 환경은 **객체 환경 레코드**와 **선언적 환경 레코드**로 나뉘는데 그중 객체 환경 레코드의 `BindingObject`에서 `conole`식별자를 찾을 수 있다.

**2) log 메서드 검색**
`console`식별자에 바인딩된 객체, 즉 `console`객체에서 `log`메서드를 검색한다. 이때 `console`객체의 프로토타입 체인을 통해 메서드를 검색한다.

**3) 표현식 a + b + x + y + z 의 평가**
식별자 `a`,`b`,`x`,`y`,`z`들을 렉시컬 환경에서 검색한다. 현재 실행중인 실행 컨텍스트의 렉시컬 환경에서 시작해 외부 환경에 대한 참조로 이어지는 렉시컬 환경을 연속해서 검색한다.
`a`실별자는 `foo`함수 렉시컬 환경에서, `b`식별자는 `bar`함수 렉시컬 환경에서, `x`와`y`식별자는 `foo`함수 렉시컬 환경에서, `z`식별자는 `bar`함수 렉시컬 환경에서 검색된다.

**4) console.log 메서드 호출**
표현식 `a + b + x + y + z`가 평가되어 생성된 값 `42`를 `console.log`메서드에 전달하여 호출한다.



### 6-8 bar 함수 코드 실행 종료

`bar`함수 코드에 더이상 실행할 코드가 없어 `bar`함수 실행을 종료한다. 이때 실행 컨텍스트 스택에서 `bar`함수 실행 컨텍스트가 **팝**되어 제거 되며 `foo`실행 컨텍스트가 실행중 컨텍스트가 된다.



### 6-9 foo 함수 코드 실행 종료

`bar`함수가 종료되면 `foo`함수도 더이상 실행할 코드가 없으므로 `foo`함수 코드의 실행도 종료된다. 이때 실행 컨텍스트 스택에서 `foo`함수 실행 컨텍스트가 **팝**되어 제거되고 **전역 실행 컨텍스트**가 실행중인 실행 컨텍스트가 된다.



### 6-10 전역 코드 실행 종료

`foo`함수가 종료되면 전역 코드도 더이상 실행할 코드가 없으므로 전역 코드의 실행도 종료되고, 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 제거된다.





## 7. 실행 컨텍스트와 블록 레벨 스코프

`var`키워드로 선언된 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 **함수 레벨 스코프**를 따른다.
하지만 `let`,`const`키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따른다.

```js
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

위 예제를 보면 if문의 코드 블록 내에서 `let`키워드로 변수가 선언되었다. 따라서 if문의 코드 블록이 실행되면 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.
이를 위해 **선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.(1)**

if문의 코드블록의 **실행이 종료되면 if문의 코드 블록이 실행되기 이전의 렉시컬 환경으로 되돌린다.(2)**



---



13장 스코프

## 1. 스코프

> 식별자가 유효한 범위
> 식별자 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 유효 범위

```js
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수

  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```



```js
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x); // local
}

foo();

console.log(x); // global
```

전역에 선언된 `var x = 'global';`과 `foo`함수 내에 선언된 `var x = 'local';`은 식별자 이름은 같지만 스코프는 다르다.
자바스크립트 엔진은 식별자를 결정할 때 “식별자를 검색할 때 사용하는 규칙”이 있다.
이때 코드의 문맥과 환경을 고려한다.

> *※코드의 문맥과 환경*
> 렉시컬 환경: 코드가 어디서 실행되며 어떤 코드가 있는지 코드의 문맥을 이루는 환경
> 실행 컨텍스트: 렉시컬 환경을 구현한 것. 모든 코드를 평가하고 실행한다.

식별자의 이름은 유일해야 하지만 스코프를 통해 식별자 이름의 충돌을 방지할 수 있다.

`var`키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.

```js
function foo() {
  var x = 1;
  // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
  // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 2;
  console.log(x); // 2
}
foo();
```

반면 `let`이나 `const`는 중복 선언을 허용하지 않는다.

```js
function bar() {
  let x = 1;
  // let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
  let x = 2; // SyntaxError: Identifier 'x' has already been declared
}
bar();
```





## 2. 스코프의 종류



### 2-1 전역과 전역 스코프

> 전역이란 코드의 가장 바깥 영역
> 전역은 전역 스코프`global scope`를 만든다.
> 전역 변수`global variable`는 어디서든 참조할 수 있다.

### 2-2 지역과 지역 스코프

> 지역이란 함수 몸체 내부를 말한다.(자바스크립트는 함수 스코프를 따르기 때문)
> 지역은 지역 스코프를(`local scope`) 만든다.
> 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.





## 3. 스코프 체인

> 함수는 중첩될 수 있어 함수의 지역 스코프도 중첩될 수 있다.
> 함수가 중첩되면 **스코프도 계층적인 구조**를 갖는다.
>
> 변수를 참조할 때 자바스크립트 엔진은 소코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프의 방향으로 이동하며 선언된 변수를 검색`identifier resolution` 한다.
>
> 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 자세한 사항은 [렉시컬 환경](https://hong-p.github.io/javascript/javascript-deepdive-ch23/#5렉시컬-환경)을 참고하자.

```js
// 전역 함수
function foo() {
  console.log('global function foo');
}

function bar() {
  // 중첩 함수
  function foo() {
    console.log('local function foo');
  }

  foo(); // ①
}

bar();
```

①에서 호출한 `foo`함수는 전역에 선언한 `foo`함수가 아니라 `bar`함수 내부에 선언한 `foo`함수를 호출 하는 것이다.
①에서 `foo();`를 호출하면 현재 실행 중인 실행컨텍스트(`bar`함수)의 렉시컬 환경에서 `foo`식별자를 먼저 검색한다. 있으면 그 식별자를 참조하고, 없는경우 외부 렉시컬환경(상위 렉시컬 환경)으로 가서 찾기를 반복한다.
이를 **식별자를 검색하는 규칙**이라고 표현한다.





## 4. 함수 레벨 스코프

> 지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다. 지역 스코프는 함수에 의해서 생성된 스코프이다.
> if, for, while try/catch 등의 코드 블록은 블록 레벨 스코프를 만든다.

```js
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
  // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
  // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

위 예제에서 처음에 선언한 `var x = 1;`의 `x`변수는 전역변수이고, `if`문 안에 선언된 `var x = 10`또한 전역 변수로 등록된다.
`var`키워드는 함수 레벨 스코프만 인정하기 때문이다.
따라서 위 코드는 `x`가 선언되고 `1`이 할당된뒤 `if`문 내의 `var x = 10;`을 만나면 `var`선언은 무시되고 `x = 10` 할당 표현식만 실행되어 `x`의 값에 `10`이 할당된다.

```js
var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```

위 예제에서도 마찬가지로 `for`문 안에에서 `var i = 0`으로 `i`변수를 선언했지만 전역 변수로 등록되어 `for`문 바깥에서도 참조할 수 있다.





## 5. 렉시컬 스코프

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

결과는 `foo() // 1`,`bar() // 1` 둘다 1이 출력된다.
이유는 함수를 어디서 호출하는지에 따라 상위 스코프가 결정되는 것 이아니고,
**함수를 어디에 정의했는지에 따라 함수의 상위 스코프가 결정**되기 때문이다.

함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.
언제나 함수가 정의된 위치가 중요하다. 즉, 렉시컬 스코프를 따른다는 것이다.

> ※ 렉시컬(lexical) : 어휘의, 사전의



만약 `bar`함수를 호출했을 때 `10`을 출력하고 싶으면 아래와 같이 `foo`함수안에 `bar`함수를 선언하여 중첩 함수를 만들고 `foo`안에서 `bar`를 호출하면 `bar`함수의 상위 스코프인 `foo`함수에 선언된 `x`가 참조되어 `10`이 출력된다.(클로저 개념)
다만 `bar`함수를 `foo`함수 바깥에서는 호출할 수 없다. 그럴경우 `Uncaught ReferenceError: bar is not defined` 에러가 발생한다.

```js
var x = 1;

function foo() {
  var x = 10;
  function bar() {
    console.log(x);
  }
  bar();
}

foo(); // ?
bar(); // ?
```

