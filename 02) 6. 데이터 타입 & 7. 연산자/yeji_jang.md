 ## 6. 데이터 타입

- 데이터 타입은 값의 종류를 말하며 자바스크립트의 모든 값은 데이터 타입을 갖는다.
- 자바스크립트는 7개의 타입을 가지며(ES6 기준), 원시 타입(Primitive Type)과 객체 타입(object, Reference Type)으로 구분된다.

> - 원시 타입 : 숫자, 문자열, 불리언, undefined, null, 심벌
> - 객체 타입 : 객체, 함수, 배열 등
### 6-1. 숫자 타입
- C나 자바는 정수와 실수를 구분해 int, long, float, double등 다양한 숫자 타입을 제공하지만 자바스크립트는 하나의 숫자 타입만 존재한다.
- ECMAScript 사양에 따르면 숫자 타입의 값은 64비트 부동소수점 형식을 따른다. 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.
- 자바스크립트는 정수 개념이 없기 때문에 정수로 표시해도 사실은 실수다
```js
console.log(1 === 1.0) // true
```
- 숫자 타입의 세 가지 특별한 값이 존재한다. 
```js
console.log(10/0); //Infinity
console.log(10/-0); //-Infinity
console.log(1 * 'String'); //NaN
```

### 6.2 문자열 타입
- 텍스트 데이터를 나타내는데 사용하며 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분 문자 표현 가능
- 작은 따옴표(”), 큰 따옴표(""), 백틱으로 텍스트를 감싸고 일반적으로는 작은 따옴표가 많이 쓰인다.
- 문자열을 따옴표로 감싸지 않으면 키워드, 식별자 같은 토큰으로 인식한다.
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값(immutable value)이다. (문자열이 생성되면 그 문자열은 변경 불가능)

### 6.3 템플릿 리터럴
- ES6에서 도입된 표기법으로 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다.
- 백틱을 통해 표현한다.

#### 1) 멀티라인 문자열
- 일반 문자열 내에서는 줄바꿈(개행) 허용되지 않음
- 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시로 시작하는 이스케이프 시퀀스를 사용해야 한다. 
```js
var template = `<ul>\n\t<li><a href="#">Home</a></li></ul>`
console.log(template)
<ul> 
	<li><a href="#">Home</a></li>
</ul>
```

#### 2)표현식 삽입
- 문자열은 문자열 연산자 +를 사용해 연결 가능, +연산자는 피연산자중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
- 템플릿 리터럴 내에 표현식 삽입을 통해 간단히 문자열 삽입이 가능하다.
- 현식을 삽입하려면 ${}으로 표현식을 감싼다.

```js
var first = 'Yeji';
var last = 'Jang';
console.log(`My name is ${first} ${last}.`);  // My name is Yeji Jang.
```

### 6-4. 불리언 타입
- 불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false.
- 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용한다

### 6-5 undefined 타입
- undefined 타입의 값은 undefined가 유일
- var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다.
- 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화된다.
- undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.
- undefined를 의도적으로 변수에 할당하면 본래 취지와 어긋나므로 권장하지 않는다.
- 값이 없다는 것을 명시하고 싶다면 null을 할당한다.

### 6-6 null 타입
- null 타입 값은 null이 유일
- null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재)할때 사용한다.

>  undefined, null, undeclared의 차이
>  - undefined은 선언후 값을 할당하지 않으면 자동으로 할당되는 값
>  - null은 비어있는 값이라는 것을 명시적으로 사용할 때 쓰는 값
>  - undeclared는 선언조차 되지 않은 식별자를 참조할때 발생하는 오류
### 6-7 심벌 타입
- ES6에서 추가된 7번째 타입
- 변경 불가능한 원시 타입의 값 (다른 값과 중복되지 않는 유일무이한 값)
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다

### 6-8 6.8 객체 타입
- 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.

### 6-9 데이터 타입의 필요성
#### 1) 데이터 타입에 의한 메모리 공간의 확보와 참조
-값은 메모리에 저장하고 참조할 수 있어야 한다.
-메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 한다.(낭비와 손실 없이 값을 저장하기 위해 )

#### 2)데이터 타입에 의한 값의 해석
- 읽어 들인 2진수를 해석할 때, 데이터 타입에 따라 해석 방법을 달리한다.

#### 3) 데이터 타입이 필요한 이유 요약
- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### 6-10 
- 자바스크립트는 변수 선언시 타입을 선언하지 않는다. var, let, const 키워드를 사용해 변수를 선언할 뿐이다.
- 자바스립트 변수는 어떤 데이터 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다.
- 자바스크립트에서는 값을 할당하는 시점에 변수 타입이 동적으로 결정되고 변수 타입을 자유롭게 변경할 수 있다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수 타입은 언제든 동적으로 변할 수 있다.
- 변화하는 변수 값을 추적하기 어렵다,
- 값을 확인하기 전에 타입을 확신할 수 없다.

## 7. 연산자
- 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 
- 연산의 대상을 피연산자(operand)라 한다.
- 피연산자는 값으로 평가될 수 있는 표현식이어야 하며, 연산자의 표현식(피연산자 + 연산자)도 표현식이다.

```js
// 산술 연산자
5 * 4 
// 문자열 연결 연산자
'My name is ' + 'Lee'
// 할당 연산자
color = 'red'
// 비교 연산자
3 > 4
// 논리 연산자
true && false
// 타입 연산자
typeof 'hello'
```

### 7-1 산술 연산자
- 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 
- 산술 연산이 불가능한 경우 NaN을 반환한다.
-이항 산술 연산자 : 2개의 피연산자를 산술 연산
- 단항 산술 연산자 : 1개의 피연산자를 산술 연산
#### 1)이항 산술 연산자
- 2개의 피연산자를 산술 연산
`+, -, *, /, %`

#### 2)단항 산술 연산자
- 1개의 피연산자를 산술 연산하여 숫자 값을 만든다
`++ : 증가, --: 감소`
- 전위 증가/감소 연산자 : 피연산자의 증가/감소 후 다른 연산 수행
- 후위 증가/감소 연산자 : 다른 연산을 수행한 후 피연산자의 값을 증가/감소

#### 3)문자열 연결 연산자
- 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

### 7-2 할당 연산자
- 할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
- 할당 연산자는 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다.

### 7.3 비교 연산자
비교 연산자는 좌항, 우항 피연산자를 비교한 후 불리언 값으로 반환하는 역할을 한다.
#### 1) 동등/일치 비교 연산자
- 동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교해 불리언 값을 반환한다.
- 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.
- `동등 비교 연산자(==)`는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
- 타입이 다르더라도 암묵적 타입 변환 후 같은 값일 수 있다면 true를 반환한다.
- `일치 비교 연산자(===)`는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한해 true를 반환한다.
- 일치 비교 연산자에서 NaN을 검사할 때는 주의해야 한다. NaN은 자신과 일치하지 않는 유일한 값이므로 (NaN === NaN을 검사하면 false가 나온다.) 

#### 2) 대소 관계 비교 연산자
-	x > y	x가 y보다 크다
- x < y	x가 y보다 작다
- x ≥ y	x가 y보다 크거나 같다
-	x ≤ y	x가 y보다 작거나 같다

### 7-4 삼항 조건 연산자
- 삼항 조건 연산자는 조건식의 평가 결과에 따라 반환된 값을 결정한다.
```js
var result = score >= 50 ? 'pass' : 'fail'
```
1. 첫 번째 피연산자가 true로 평가되면 두 번째 피연산자를 반환
2. false이면 세 번째 피연산자를 반환한다.
- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.
- 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만, if…else 문은 값처럼 사용할 수 없다.

### 7.5 논리 연산자
논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.
- &&	논리식이 모두 참이면 참을 반환함. (AND 연산)
- ||	논리식 중에서 하나라도 참이면 참을 반환함. (OR 연산)
- !	논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (NOT 연산)

> 드 모르간의 법칙
> - 드 모르간의 법칙을 활용하면 복잡한 표현식을 더 가독성 좋은 표현식으로 변환할 수 있다.
> - !(x || y) === (!x && !y)
> - !(x && y) === (!x || !y)
### 7-6 쉼표 연산자
- 쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.
```js
var x,y,z; 
x=1, y=2, z=3; //3 
```
### 7-7 그룹 연산자
- 소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. (연산 우선순위 조절 가능하며 그룹 연산자 우선순위가 가장 높다).
```js
10*2 + 3; 
10 * (2+3);//그룹이 먼저 계산됨
```
### 7-8 typeof 연산자
- 피연산자의 데이터 타입을 문자열로 반환한다.
- typeof 연산자는 7가지 문자열 `string`, `number`, `boolean`, `undefined`, `symbol`, `object`, `function` 중 하나를 반환한다.
- null은 없기 때문에 typeof null은 `object`를 반환한다.
- 선언하지 않은 식별자를 typeof 연산자로 연산해보면 ReferenceError가 아닌 `undefined`를 반환한다.
### 7-9 지수 연산자
- ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.
- Math.pow를 통해서도 표현이 가능하며 지수 연산자 이전에는 이 방식을 사용했다.
```js
2 ** 2 // 2의 2제곱
2 ** 2.5 // 2의 2.5제곱
2 ** 0 // 2의 0제곱
2 ** -2 // 2의 -2 제곱
Math.pow(2, 2)
Math.pow(2, 2.5)
Math.pow(2, 0)
Math.pow(2, -2)
```
- 음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다.
- 지수 연산자는 할당 연산자와 함께 사용할 수 있으며, 이항 연산자 중에서 우선 순위가 가장 높다.

### 7-10 그 외의 연산자
1. ?.(Optional chaining, 옵셔널 체이닝 연산자) 
- 체인의 각 참조가 유효한지 명시적으로 검증하지 않고, 연결된 객체 체인 내에 깊숙이 위치한 속성 값을 읽을 수 있다.
- 참조가 nullish(null 또는 undefined)하다면, 에러가 발생하는 대신 표현식의 리턴 값을 undefined로 한다.
- 참조에 대한 직접 접근에 대한 에러를 방지함으로써 에러 안정성을 높여준다.

2. ?? (Nullish coalescing operator, 널 병합 연산자) 
- 왼쪽 피연산자가 null 또는 undefined일 때 오른쪽 피연산자를 반환하고, 그렇지 않으면 왼쪽 피연산자를 반환하는 논리 연산자이다.
- 논리 연산자 OR (||)이 falsy 값에 해당할 경우 오른쪽 피연산자를 반환하는 것에 반해, ” 또는 0 같은 falsy 값을 포함하고자 한다면 OR 연산자 대신 널 병합 연사자를 사용할 수 있다.

delete : 객체의 속성을 제거한다.  
new : 사용자 정의 객체 타입 또는 재아 객체 타입의 인스턴스를 생성한다.  
instanceof : 생성자의 prototype 속성이 객체의 프로토타입 체인 어딘가 존재하는지 판별한다.  
in : 명시된 속성이 명시된 객체에 존재하면 true를 반환한다.  


### 7-11 연산자의 부수 효과
- 다른 코드에 영향을 주는 부수 효과를 가진 연산자에는 할당 연산자(=), 증가/감소 연산자(++/—), delete 연산자가 있다.
### 7-12 연산자 우선순위
- 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서
- 높을수록 먼저 실행된다
