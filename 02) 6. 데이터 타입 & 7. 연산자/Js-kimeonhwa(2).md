6장  데이터타입

#### 데이터 타입

데이터 타입은 값의 종류를 의미한다

자바스크립트의 모든 값은 데이터 타입을 갖는다. 

ES6에서는 7개의 데이터 타입을 제공한다

.7개의 데이터 타입은 원시타입(primitive type)과 객체 타입(object / reference type)으로 분류할 수 있다.

> 참고:
> ECMAScript2020(ES11)에서는 새로운 원시값 [Bigint](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt)가 추가되었다.
> Bigint를 사용하면 JavaScript 에서도 [BigDecimal](https://velog.io/@indongcha/실수의-표현방식-부동소수점IEEE-754)을 구현할 수 있다.
> (이미 많은 라이브러리가 존재한다)



#### 숫자 타입

자바스크립트는 **숫자타입**만을 제공한다.

```js
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수
```

> 정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 **배정밀도 64비트 부동소수점** 형식의 **2진수**로 저장된다. 또한 숫자타입 값은 모두 **10진수로 해석**된다.



```js
var binary = 0b01000001;//2진수
var octal = 0o101; //8진수
var hex = 0x41; //16진수

// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary); //65
console.log(octal); //65
console.log(hex); //65
console.log(binary === octal) //true
console.log(octal === hex) // true
```

자바스크립트는 정수타입을 따로 제공하지 않기에 모든 숫자타입 값은 실수로 처리한다. 

이는 **정수로 표시해도 사실 실수라는 것**을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.

```js
//숫자타입은 모두 실수로 처리된다.
console.log(1 === 1.0); //true
console.log(4 / 2); //2
console.log(3 / 2); //1.5
```



숫자 타입은 추가적으로 세 가지 특별한 값도 표현 할 수 있다

- Infinity : 양의 무한대

```js
console.log(10 / 0); //Infinity
```

- -Infinity : 음의 무한대

```js
console.log(10 / -0); //-Infinity
```

- NaN: 산술 연산 불가(not-a-number)

```js
console.log(1 * 'String'); //NaN
```





#### 문자열 타입

문자열은 작은따옴표(''), 큰따옴표(""), 백틱으로 텍스트를 감싼다.

문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 **토큰과 구분**하기 위함이다.
또한 따옴표로 문자열을 감싸지 않는다면 공백문자도 포함할 수 없다.

```js
var string = hello;//ReferenceError: hello is not defined
var string2 = hello world; // hello라는 식별자와 world라는 식별자를 나열한 것으로 문법에러
```

> C언어에서는 문자열은 문자의 배열료 표현하고, Java에서는 객체로 표현한다. 하지만 자바스크립트의 문자열은 원시타입이며 변경 불가능한 값(immutable value)이다.





### 템플릿 리터럴

ES6부터 템플릿 리터럴이 도입

- 템플릿 리터럴은 멀티라인 문자열, 표신식 삽입, 태그드 템플릿과 같은 편리한 문자열 처리 기능을 제공한다.

- 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

- 템플릿 리터럴은 백틱을 사용해 표현한다.

```js
var template = `template literal`;
console.log(template);//template literal
```



#### 멀티라인 문자열

일반 문자열 내에서는 줄바꿈이 허용되지 않는다

따라서 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 이스케이프 시퀀스를 사용해야 한다

- 줄바꿈 문자 : \n, 탭은 \t

```js
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
console.log(template);

//출력 결과
<ul>
	<li><a href="#">Home</a></li>
<ul>
    
// 템플릿 리터럴 사용
var template = `<ul>
	<li><a href="#">Home</a></li>
</ul>`;
console.log(template);    
```





#### 표현식 삽입

문자열 중에서 특정 내용만 변수처리를 하고 싶을 때 사용할 수 있다. 

ES5스팩 까지는 해당 기능이 제공되지 않아 문자열 연결 연산자를 사용해 이를 출력하였다.

```js
var first = 'eonhwa';
var last = 'Kim';

//ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); //My name is eonhwa Kim

------------------------------------

//템플릿 리터럴 내에서 표현식 삽입을 통해서 간단하게 동일한 내용을 출력할 수 있다. 이는 문자열 연산자보다 가독성도 뛰어나다.

var first = 'eonhwa';
var last = 'Kim';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`); // My name is eonhwa Kim.

```

- 표현식을 삽입하려면 **${}**으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 **타입이 문자열로 강제 변환**되어 삽입된다. 표현식 삽입은 **반드시 템플릿 리터럴 내에서 사용** 해야한다. 그렇지 않으면 일반 문자열로 취급한다.



#### 불리언 타입

논리적 참, 거짓 을 나타내느 true와 false 뿐이다

- 불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어할 때 사용한다.





#### undefined 타입

undefined 타입의 값은 undefined가 유일하다.

- var 키워드로 선언한 변수는 암묵적으로 undefined로 초기회 된다. 값을 저장하기 위해 메모리에 공간을 확보할 때 해당 공간을 빈 값(대부분 쓰레기 값이 들어있음)으로 내버려두지 않고 undefined로 초기화 한다. 따라서 변수를 선언하고 아무런 할당없이 해당 변수를 참조하면 undefined가 반환된다.

```js
var foo;
console.log(foo); //undefined
```

- undefined를 직접 할당하는 것은 권장하지 않는다. undefined는 자바스크립트 엔진이 변수를 초기화 할때 사용하는 값이므로 이를 통해서 어떤 변수를 참조할 때 undefined가 반환된다면 선언 후 한번도 할당되지 않았다는 것을 알 수 있다. 이것이 undefined의 본래 취지이며 이를 임의로 사용하는 것은 좋지 않다.

만약 변수에 값이 비어있다는 것을 의미하고 싶다면 null을 할당하면 된다.





#### null 타입

null 타입의 값은 null이 유일하다.

-  프로그래밍 언어에서는 null을 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 이를 **의도적 부재**라 한다. 변수에 null을 할당한다는 것은 **변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미**다.

```js
var foo = 'Lee';

// 이전 참조를 제거. foo 변수는 더이상 'Lee'를 참조하지 않는다.
// javascript는 C언어 처럼 메모리를 개발자가 직접 관리하지 않기 때문에 
// null을 할당한다고 곧바로 foo에 할당되어있던 'Lee'의 메모리가 릴리즈 되지는 않는다.
// 이는 가비지컬랙터의 동작에 대한 이해가 필요하다.
foo = null;
```

- 또한 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.



#### 심벌 타입

ES6 스팩에서 추가된 7번째 타입으로, 변경이 불가능한 원시 타입의 값이다. 심벌 값은 **다른 값과 중복되지 않는 유일무이한 값**이다. 따라서 주로 객체의 프로퍼티 키로 사용한다. 키 값으로 심벌 타입의 값을 사용하면 키가 충돌할 일이 없어진다.

```js
var key = Symbol('key');
console.log(typeof key); // Symbol

//객체 생성
var obj = {};

// 이름이 충돌되지 않도록 심볼을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value
```



#### 객체 타입

자바스크립트의 데이터 타입은 크게 원시타입과 객체타입으로 분류할 수 있다. 원시타입과 객체타입은 근본적인 차이가 있기 때문이다. 



### 데이터 타입의 필요성

#### 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야한다. 그런데 메모리에 값을 저장하려면 먼저 확보해야할 공간의 크기를 정해야한다. 즉, **몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 저장할 수 있는지 알아야**한다.

```js
var scroe = 100;

// 위 코드가 실행하면 100에 해당하는 값을 저장하기 위해서 공간을 확보하고 숫자 값 100을 2진수로 저장하게 된다. 즉 먼저 공간의 크기를 적절히 정해야지 값을 저장할 수 있는 것이다.
// 자바스크립트 엔진은 값의 데이터 타입에 따라서 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라서 확보해야할 메모리 공간의 크기가 결정된다.

// 자바스크립트 엔진에서는 숫자타입의 값을 저장하기 위해서 8바이트의 메모리 공간을 확보한다. 그리고 100을 이진수로 저장한다
```



#### 데이터 타입에 의한 값의 해석

 만약 메모리에 0100 0001이 저장되어있고 이를 숫자로 해석하면 65이지만, 문자열로 해석하면 'A'이다. 이 때 **어떤 데이터 타입의 값이냐에 따라 해석이 정해진다**.

> 데이터 타입의 필요성 정리 
>
> - 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
> - 값을 참조할 때 한 번에 읽어 들어야 할 메모리 공간의 크기를 결정하기 위해
> - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해



### 동적 타이핑

> 자바스크립트의 모든 값은 데이터 타입을 가진다. 하지만 변수는 데이터 타입을 가지지 않는다.

#### 동적 타입 언어와 정적 타입 언어

- C나 자바 같은 **정적 타입 언어**는 **변수를 선언할 때 해당 변수에 할당할 수 있는 데이터 타입을 사전에 선언**해야 한다. 이를 명시적 선언이라 한다.
  - 정적 타입 언어는 변수의 타입을 변경할 수 없으며, **변수에 선언한 타입과 맞는 값만 할당 가능**하다. 정적타입 언어는 컴파일 시점에 타입체크를 수행한다. 만약 이를 통과하지 못한다면 프로그램 자체가 실행되지 않는다. 이를 통해 **타입의 일관성을 강제**하므로 **안정적인 코드**를 구현할 수 있으며, 런타입에 발생하는 에러를 줄일 수 있다.
- 하지만 자바스크립트는 변수를 선언할 때 타입을 선언하지 않는다. var, let const 키워드만 사용할 뿐이다. 자바스크립트의 변수에는 어떤 타입의 값이이라도 할당이 가능하다.

```js
// typeof 연산자는 변수의 데이터 타입이 아닌 변수에 할당된 값의 데이터 타입을 반환한다 

var foo;
console.log(typeof foo); // undefined;

foo = 3;
console.log(typeof foo); // number

foo = 'hello';
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // booean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console.log(typeof foo); // symbol

foo = {};
console.log(typeof foo); // object

foo = [];
console.log(typeof foo); //object

foo = function () {};
console.log(typeof foo); // function
```

=> 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다

그리고 재할당에 의해 변수의 타입이 언제든지 동적으로 변할 수 있다 이러한 특징을 동적타이핑이라고 한다 



#### 동적 타입 언어와 변수

동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 이는 매우 편리하지만 이면에는 위험도 도사리고 있다.
복잡한 프로그램 안에서 변수의 값은 빈번히 변하게 되고, 동적 타입 언어는 변수에 어떤 값이 할당 되냐에 따라서 데이터 타입이 변하기 까지 한다. 그러므로 동적 타입 언어는 변수의 값을 확인하기 전에는 타입을 확신할 수 없다.

또한 자바스크립트는 개발자의 의도와 상관없이 자바스크립트 엔진의 암묵적인 룰에 의해서 타입이 자동으로 변하기도 한다. 숫자 타입이라고 예측하고 프로그램을 짯지만 알고보니 문자 타입의 변수일 수도 있다.

결국 이러한 이유로 변수를 사용하기 전에 매번 데이터 타입을 체크하게 되는데 이는 번거로울 뿐아니라 코드의 양도 증가하고 지저분해진다.

따라서 변수를 사용할 때 아래의 주의점을 참고하자.

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
- 변수의 스코프를 최대한 좁게 만들어야 한다.
- 전역 변수는 최대한 사용하지 않는다.
- 변수보다는 최대한 상수를 사용한다.
- 의미있는 변수 네이밍이 필요하다.







---

7장 : 연산자



### 연산자

연산자는 **하나 이상의 표현식**을 대상으로 산술, 할당, 비교, 논리, 타입 지수 연산 등을 수행해 **하나의 값**을 만든다.

- 피연산자는 연산자의 연산대상이며, 값으로 평가될 수 있는 표현식이어야 한다.
- 피연산자와 연산자의 조합으로 이뤄진 표현식도 **값으로 평가될 수 있는 표현식**이다.



#### 산술 연산자

산술 연산자는 피연산자를 대상으로 **수학적 계산**을 수행해 **새로운 숫자 값**을 만든다. 연산이 불가능한 경우 NaN(Not a Number)를 반환한다.



##### 이항 산술 연산자

2개의 피연산자를 산술하여 숫자 값을 만든다.
모든 이항 산술 연산자는 부수효과(side effect)가 없다.



##### 단항 산술 연산자

한 개의 피연산자를 산술 연산하여 숫자 값을 만든다.

주의할 점은 증가/감소 연산자는 **피연산자의 값을 변경하는 부수 효과가 있다**는 것이다. 즉 증감 연산자는 피연산자의 값을 증감 후 암묵적으로 할당이 이뤄진다.

```js
var x = 1;
x ++; // x = x + 1과 동일
console.log(x) // 2 <- 부수효과를 가져온다.

x --; // x = x - 1과 동일
console.log(x) // 3
```

> 증감연산자
>
> - 전위 증감 연산자는 먼저 피연산자의 값을 증감 후, 다른 연산을 실행한다.
> - 후위 증감 연산자는 먼저 다른 연산을 실행 후, 피연산자를 증감한다.

```js
var x = 5;
var result;

result = x++; // 선 할당, 후 증가
console.log(x, result); // 5, 6

result = ++x; // 선 증가, 후 할당
console.log(x, result); // 7, 7


// 이와 다르게 +/- 단항연산자는 부수효과가 없다
+10; // 10
+(-10) // -10
```



숫자 타입이 아닌 피연산자에 +연산자를 붙이면 **숫자타입으로 형변환**이 일어난다. 이때 피연산자의 값을 변경하는 게 아닌 **새로운 값을 반환**한다.

- 단항 연산자는 부호를 반전한 값을 반환한다. + 단항 연산자와 동일하게 숫자 타입이 아닌 피연산자에 붙이면 숫자 타입으로 형변환하여 값을 반환한다.



#### 문자열 연결 연산자

- 이항 연산자는 피연산자 중 하나 이상이 문자열인 경우 **문자열 연결 연산자**로 동작한다.

```js
// 문자열 연결 여산자
'1' + 2; // 12

// 산술 연산자
 1 + 2; // 3

//true는 1로 타입 변환된다.
true + 1; // 2

//false는 0으로 타입 변환된다.
false + 1; // 1

// undefined는 숫자로 타입 변환이 되지 않는다.
+undefined; // NaN
1 + undefined; // NaN
```

=>  자바스크립트 엔진이 암묵적으로 형변환 시킨다는 것이다. 이를 압묵적 타입변환, 강제 타입 변환이라 한다.



### 할당 연산자

우항에 있는 피연산자의 평과 결과를 좌항에 있는 변수에 할당한다. 

할당 연산자는 좌항의 변수에 값을 할당하므로 부수효과가 있다.

```js
// 할당문은 표현식이다, 값으로 평가되며 이는 표현식인 문인다
var x;
console.log(x = 10); // 10
```





### 비교 연산자

좌항과 우항의 피연산자를 비교하여 그 결과를 불리언 값으로 반환한다. 비교 연산자는 if나 for의 조건식에 주로 사용된다.



##### 동등/일치 비교 연산자 

좌항과 우항을 비교하여 동일한지 비교하여 그 결과를 불리언 값으로 반환한다. 동등 비교 연산자와 일치 비교 연산자는 엄격성에서 차이가 있다.
동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.

```js
// 자바스크립트 엔진은 암묵적으로 타입을 자동변환한다. 동등 비교 연산자는 좌 우항의 피연산자를 비교 연산할 때 암묵적 형변환을 통해 타입을 일치시키고 값이 같은지 비교한다.
5 == '5'; // true
5 == 5; // true
```

```js
// 동등 비교 연산자는 예측하기 어렵고 실수하기도 쉽다. 그러므로 동등 비교 연산자보다는 일치 비교 연산자를 사용하는 것이 좋다.

// 동등 비교 연산자
'0' == ''; // false
0 == ''; // true
0 == '0'; // true
false == 'false'; // false
false == '0'; // true
false == null // false
false == undefined // false

// 일치 비교 연산자
5 === 5 // true
5 === '5' // false
```

```js
// 일치 비교 연산자에서 주의할 것은 NaN의 비교다. NaN은 자신과 일치하지 않는 유일한 값이다. 그러므로 NaN을 조사하기 위해서는 빌트인 함수 Number.isNaN을 사용한다.
NaN === NaN; // false
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined) // ture


// 또한 숫자 0의 비교에도 주의해야 한다.
0 === -0 // true
0 == -0 // true
//숫자 0의 경우 동등/일치 비교 연산자 모두 비교 결과는 true를 반환한다.

// => 부동등/불일치 비교 연산자는 각각 동등/일치 비교 연산자의 반대 개념이다.
```



#### 대소 관계 비교 연산자

 좌 우항의 피연산자의 크기를 비교하여 불리언 값을 반환환다.

```
> < >= <= 
```



### 삼항 조건 연산자

조건식의 평가 결과에 따라서 반환할 값을 결정한다.(부수효과는 없다)

```js
var x = 2;
// 2를 2로 나눈 나머지는 0이며 0은 false로 자동 형변환 된다.
var result = x % 2 ? 'odd' : 'even';
console.log(result); // even


//삼항 조건 연산자는 if - else 문으로도 표현할 수 있다.
var x = 10;
var result;

if (x % 2) { 
  result = 'odd' 
} else { 
  result = 'even' 
};

console.log(result); // even


//if - else문과 삼항 조건 연산자는 중요한 차이점이 있다. 삼항 조건 연산자는 값처럼 사용할 수 있지만, if - else 문은 값 처럼 사용 할 수 없다.
var x = 10;
var result = if (x % 2) { result = 'odd' } else { result = 'even' };
//SyntaxError: Unexpected token if

```

> 그러므로 삼항 조건 연산자는 표현식인 문이지만, if - else 문은 표현식이 아닌 문이다.
>
> 삼항 조건 연산자를 값으로 사용할 수 있는 장점이 있으나, 상황에 따라서는 if - else 문을 사용하는 것이 가독성면에서 좋을 수 있다.



### 논리 연산자

좌 우항의 피연산자를 논리연산한다.

```js
//논리합 연산자
true || true; // true
true || false; // true
false || true; // true
false || false; // false;

// 논리곱 연산자
true && true; // true
true && false; // false
false && true; // false
false && false; // false

// 논리 부정 연산자
!true; // false
!false; // true


//논리 부정 연산자는 항상 불리언 값을 반환한다. 이때 피연산자가 꼭 불리언 값일 필요는 없다. 불리언 값이 아닐 경우는 암묵적으로 타입이 변환된다.
!0; // true
!'Hello'; // false

```



#### 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```js
var x, y, z;
x = 1, y = 2, z = 3; // 3
```



#### 그룹 연산자

소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다. 그룹 연산자는 연산자 우선순위가 가장 높다.

```js
10 * 2 + 3; // 23
10 * (2 + 3); // 50
// 연산자 우선순위에 의해서 곱하기 연산자가 더하기 연산자보다 우선순위가 높으나 그룹 연산자로 더하기 연산자를 감싸고 있어 이를 먼저 연산 후 곱하기 연산을 한다.
```





#### typeof 연산자

피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 아래 코드와 같이 7개의 문자열 중 하나를 반환하며, 'null'은 반환하지 않는다.

```js
typeof ''; // 'string'
typeof 1; // 'number'
typeof NaN; // 'number'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Symbol(); // 'symbol'
typeof null; // 'object'
typeof []; // 'object'
typeof {}; // 'object'
typeof new Date(); // 'object'
typeof /test/gi; // 'object'
typeof function (){} // 'function'

//typeof 연산자로 null을 연산하면 'null'이 아닌 'object'가 반환된다. 이는 자바스크립트의 첫 번째 버전의 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.

// 그러므로 값이 null타입인지 확인할 때는 typeof연산자가 아닌 일치 연산자를 사용해야한다.
var foo = null;

typeof foo === null; // false

foo === null; //  true

//선언하지 않은 식별자를 typeof 연산자로 연산하면 ReferenceError가 발생하지 않고 undefined가 반환된다.
typeof undeclared; // undefined

```





#### 지수 연산자

 ES7에 도입

 지수연산자는 좌항의 피연산자를 밑으로 하고, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값을 반환한다.

```js
2 ** 2; // 4
2 ** 0; // 1
2 ** -2; // 0.25

//지수 연산자가 도입되기 이전에는 Math.pow 메소드를 사용하였다/
Math.pow(2, 2); // 2

//지수 연산자가 다음과 같은 경우 Math.pow 메소드 보다 가독성이 좋다.
2 ** (3 ** 2); // 512
Math.pow(2, Math.pow(3,2)); // 512

//음수를 거듭제곱의 밑으로 사용해 계산하려면 다음과 같이 괄호로 묶어야 한다.
(-5) ** 2; // 25

// 할당 연산자와 함께 사용할 수 있다.
var num = 5;
num **= 2; //25

//지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.
2 * 5 ** 2; // 50
```





### 연산자의 부수 효과

대부분의 연산자는 부수 효과를 일으키지 않지만 일부 연산자는 부수효과가 있다.
할당 연산자, 증감연선자, delete연산자가 그러하다.

```js
var x;

// 할당 연산자는 변수 값이 변하는 부수 효과가 있다. 
//이는  x 변수를 사용하는 다른 코드에 영향을 준다.
x = 1;
console.log(x); // 1

// 증감 연산자는 피연산자의 값을 변경하는 부수혀과가 있다.
// 사실상 피연산자 변수 x에 값이 재할당되는 것이다.
// x = x + 1;
x ++;
console.log(x);

// delete 연산자는 객체의 프로퍼티를 삭제하는 부수효과가 있다.
// 해당각체를 사용하는 다른 코드에 영항을 준다.
var o = { a: 1 };
delete o.a;
console.log(o);
```



### 연산자 우선순위

명령어가 여러 연산자로 이뤄져있을 경우 연산자 간의 우선순에 맞춰서 연산하게 된다.
즉 우선순위가 높은 연산자 일수록 먼저 실행된다.

> 연산자
>
> - ?. : 옵셔널 체이닝 연산자 
> - ?? : null 병합 연산자
> - delete : 프로퍼티 삭제
> - new : 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
> - instanceof : 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
> - in : 프로퍼티 존재 확인
>
> 우선순위
>
> 1. ?? (null 병합 연산자)
> 2. &&
> 3. ||
> 4. ? ... : ...
> 5. 할당 연산자 ( =, +=, -=, ...)
> 6. , 



### 연산자 결합 순서

 연산자의 어느 쪽 부터 평가를 수행할 것인지를 나타내는 순서를 말한다.

> 좌항 -> 우항
>
> - +, -, /, %, < . <=, > , >= , &&, ||, . , [], (), ?? , ?. , in, instanceof
>
> 우항 -> 좌항
>
> - ++, --, 할당 연산자(=,+=,-=,...), !x, +x, -x, ++x, typeof, delete, ?...:..., **

